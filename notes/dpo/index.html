<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content=""> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Reinforcement Learning with Human Feedback | Mike Zhou </title> <meta name="author" content="Mike Zhou"> <meta name="description" content="Mike Zhou - Computer Science and Mathematics student at the University of Pennsylvania (UPenn). Undergraduate researcher at Penn's Cognitive Computation Group working on NLP and machine learning. "> <meta name="keywords" content="Mike Zhou, UPenn, University of Pennsylvania, Computer Science, Mathematics, NLP, Machine Learning, Cognitive Computation Group, Penn SEAS, undergraduate researcher"> <meta property="og:site_name" content="Mike Zhou"> <meta property="og:type" content="website"> <meta property="og:title" content="Mike Zhou | Reinforcement Learning with Human Feedback"> <meta property="og:url" content="https://mikezhou.me/notes/dpo/"> <meta property="og:description" content="Mike Zhou - Computer Science and Mathematics student at the University of Pennsylvania (UPenn). Undergraduate researcher at Penn's Cognitive Computation Group working on NLP and machine learning. "> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Reinforcement Learning with Human Feedback"> <meta name="twitter:description" content="Mike Zhou - Computer Science and Mathematics student at the University of Pennsylvania (UPenn). Undergraduate researcher at Penn's Cognitive Computation Group working on NLP and machine learning. "> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Mike Zhou"
        },
        "url": "https://mikezhou.me/notes/dpo/",
        "@type": "WebSite",
        "description": "Mike Zhou - Computer Science and Mathematics student at the University of Pennsylvania (UPenn). Undergraduate researcher at Penn's Cognitive Computation Group working on NLP and machine learning.
",
        "headline": "Reinforcement Learning with Human Feedback",
        
        "sameAs": ["https://scholar.google.com/citations?user=qc6CJjYAAAAJ"],
        
        "name": "Mike Zhou",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://mikezhou.me/notes/dpo/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Mike</span> Zhou </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item active"> <a class="nav-link" href="/notes/">notes <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/about/">about </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Reinforcement Learning with Human Feedback</h1> <p class="post-description"></p> </header> <article> <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0823RLC0T3"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0823RLC0T3");</script> <h2>The Alignment Challenge</h2> <p>Language models have become remarkably capable through self-supervised learning on vast corpora of human-written text. They’ve learned to predict the next word with impressive accuracy, absorbing patterns of knowledge, reasoning, and even some semblance of common sense. Yet, there’s a fundamental gap between predicting the next word and generating text that humans genuinely find helpful, harmless, and honest.</p> <p>This gap exists because the core objective of predicting the next token doesn’t distinguish between the quality of different human writings. If 50% of explanations about a scientific concept contain a common misconception, we don’t want our model to generate that misconception about half the time. Similarly, while GitHub contains enormous amounts of code, only a fraction represents best practices—yet we want our models to understand and generate high-quality code, not merely replicate the average.</p> <p>This is the alignment challenge: how do we guide these powerful systems toward generating text that reflects human preferences and values, rather than simply reproducing the statistical patterns found in training data? How do we teach models to distinguish what should be written from what is written?</p> <h2>The Conceptual Foundation of RLHF</h2> <p>Reinforcement Learning from Human Feedback emerged as a powerful paradigm for aligning language models with human preferences. At its heart lies a simple idea: rather than trying to specify exactly what makes text “good” through rules or examples, we can learn what humans prefer directly from their comparative judgments. The key insight of RLHF is that humans find it much easier to compare two outputs and express a preference than to articulate exactly why one output is better than another. This relative preference signal turns out to be remarkably powerful for learning to generate better text.</p> <p>Consider a simple example: if we ask a human whether they prefer response A or response B to a given query, they can usually make that judgment quite easily. But if we ask them to assign an absolute quality score to either response in isolation, or to articulate precisely what makes their preferred response better, they often struggle.</p> <p>RLHF capitalizes on this insight by:</p> <ol> <li>Collecting many such comparative judgments</li> <li>Learning a reward model that can predict these preferences</li> <li>Using this model to guide a language model toward generating preferred outputs</li> </ol> <p>This approach has proven remarkably effective, enabling language models to produce outputs that better align with human values and preferences.</p> <h4>The Traditional RLHF Pipeline</h4> <p>The traditional RLHF approach unfolds as a three-stage process, with each stage building upon the previous one. Let’s explore the conceptual flow of this pipeline, focusing on the key ideas rather than implementation details.</p> <ol> <li> <p><strong>Supervised Fine-Tuning (SFT)</strong>: Create a foundation for further alignment by training the model on examples of desired behavior.</p> </li> <li> <p><strong>Reward Modeling</strong>: Learn to predict human preferences by training a model on pairs of outputs where humans indicated which they preferred.</p> </li> <li> <p><strong>Reinforcement Learning Optimization</strong>: Use the reward model to optimize the language model’s outputs through reinforcement learning.</p> </li> </ol> <p>The main idea of this approach is to progressively refine the model’s understanding of human preferences. First, we give the model a basic understanding of the types of responses we want through examples (SFT). This way, it makes the aligning stage much more stable. Then, we teach it to distinguish between better and worse responses by learning from human comparative judgments (reward modeling). Finally, we use this learned understanding to guide the model toward generating better responses (RL optimization).</p> <h4>Learning What Humans Prefer</h4> <p>The first part to understand within RLHF is the reward modeling stage. Imagine we have collected thousands of preference pairs: for each prompt \(x\), we have two responses, \(y_1\) and \(y_2\), along with a human judgment about which response is preferred. Our goal is to learn a function \(r(x, y)\) that assigns higher values to preferred responses.</p> <p>The standard approach uses the Bradley-Terry preference model, which gives the probability that \(y_1\) is preferred to \(y_2\) for prompt \(x\) as:</p> \[p(y_1 \succ y_2 \mid x) = \frac{\exp(r(x, y_1))}{\exp(r(x, y_1)) + \exp(r(x, y_2))} = \sigma(r(x, y_1) - r(x, y_2))\] <p>where \(\sigma\) is the logistic function. This model has an intuitive interpretation: the probability of preferring one response over another depends on the difference in their reward values.</p> <p>Training our reward model to predict human preferences will make our model learn a function that captures preferable human behaviors. Once trained, this reward model can evaluate any response to any prompt, providing a signal for what humans would likely prefer.</p> <h4>The Challenge of Reinforcement Learning</h4> <p>With a trained reward model in hand, the final stage of traditional RLHF uses reinforcement learning to optimize the language model’s policy on the learned reward model. This involves a delicate balance: maximizing the reward while preventing the model from deviating too far from its original capabilities.</p> <p>The RL objective typically takes the form:</p> \[\max_{\pi} \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi(y\mid x)}[r(x, y)] - \beta \cdot \text{KL}[\pi(y\mid x) \mid \pi_{\text{ref}}(y\mid x)]\] <p>where:</p> <ul> <li>\(\pi\) is the policy we’re optimizing</li> <li>\(r(x, y)\) is the reward function</li> <li>\(\beta\) controls how strongly we penalize deviation from the reference policy \(\pi_{\text{ref}}\)</li> <li>KL refers to the Kullback-Leibler divergence, which measures how different two probability distributions are</li> </ul> <p>While conceptually elegant, this approach introduces significant practical challenges:</p> <ul> <li>Reinforcement learning algorithms can be unstable and sensitive to hyperparameters</li> <li>The process is computationally expensive, requiring many model evaluations</li> <li>It creates a complex pipeline with multiple components that must work together</li> <li>As the policy changes during RL, the distribution of outputs shifts, potentially making the reward model less reliable</li> </ul> <h2>The Optimal Policy Under a KL Constraint</h2> <p>This innate instability and computational infeasibility of training a reward model on human preferences while training a model on the reward model introduces the question: is there a way to train directly on human rankings and skiup the reward model step altogether?</p> <p>We first examine that, for any reward function \(r(x,y)\), the optimal policy \(\pi_r\) that maximizes the expected reward while staying close to a reference policy \(\pi_{\text{ref}}\) (as measured by KL divergence) has a specific mathematical form:</p> \[\pi_r(y\mid x) = \frac{1}{Z(x)} \pi_{\text{ref}}(y\mid x) \exp\left(\frac{1}{\beta}r(x,y)\right)\] <p>where \(Z(x)\) is a normalizing constant (partition function) that ensures the distribution sums to 1:</p> \[Z(x) = \sum_y \pi_{\text{ref}}(y\mid x) \exp\left(\frac{1}{\beta}r(x,y)\right)\] <p>To demonstrate why, if we recall the RL objective</p> \[\max_{\pi} \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi(y\mid x)}[r(x, y) - \beta \cdot \text{KL}[\pi(y\mid x) \mid \pi_{\text{ref}}(y\mid x)]]\] <p>Notice that this is equivalent to minimizing</p> \[\min_{\pi} \text{KL}[\pi(y\mid x) \mid \pi_{\text{ref}}(y\mid x)] - \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi(y\mid x)}[ \frac{1}{\beta}r(x, y)]\] \[=\min_{\pi} \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi(y\mid x)} \left[ \text{log}\left(\frac{\pi(y \mid x)}{\pi_{\text{ref}}(y\mid x)} \right)- \frac{1}{\beta}r(x, y) \right]\] \[= \min_{\pi} \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi(y\mid x)} \left[ \text{log}\left(\frac{\pi(y \mid x)}{\frac{1}{Z(x)} \pi_{\text{ref}}(y\mid x) \exp\left(\frac{1}{\beta}r(x,y)\right)} \right)- \text{log}(Z(x))\right]\] <p>Because \(\frac{1}{Z(x)} \pi_{\text{ref}}(y\mid x) \exp\left(\frac{1}{\beta}r(x,y)\right)\) forms a valid probablity distribution, this is equivalent to</p> \[= \min_{\pi} \text{KL} \left[\pi(y\mid x) \big\mid \frac{1}{Z(x)} \pi_{\text{ref}}(y\mid x) \exp\left(\frac{1}{\beta}r(x,y)\right) \right] - \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi(y\mid x)} \text{log}(Z(x))\] <p>By Gibb’s Inequality, this is minimized when \(\pi(y \mid x) = \frac{1}{Z(x)} \pi_{\text{ref}}(y\mid x) \exp\left(\frac{1}{\beta}r(x,y)\right)\), finishing the proof. This tells us that the optimal policy applies a Boltzmann distribution over rewards, scaled by the reference policy. Higher rewards lead to higher probabilities in the optimal policy, with the KL constraint (controlled by \(\beta\)) determining how much the optimal policy can deviate from the reference policy.</p> <p>We can rearrange this insight on the optimal policy to express the reward function in terms of the policy:</p> \[r(x,y) = \beta \log \frac{\pi_r(y\mid x)}{\pi_{\text{ref}}(y\mid x)} + \beta \log Z(x)\] <p>Of course, we don’t know the optimal policy—that’s what we’re trying to learn. But we do have human preference data that tells us which outputs are preferred to others. And since under the Bradley Terry model, the probability of a human preferring one output over another only deals with the differences in their rewards, we have some nice cancellation properties (keep in mind that \(Z(x)\) is very hard to calculate, so we would like to get rid of that).</p> <p>First, the Bradley Terry model says that</p> \[p(y_1 \succ y_2 \mid x) = \sigma(r(x, y_1) - r(x, y_2))\] <p>If we substitute our rearranged reward function, we get</p> \[p(y_1 \succ y_2 \mid x) = \sigma\left(\beta \log \frac{\pi_r(y_1\mid x)}{\pi_{\text{ref}}(y_1\mid x)} + \beta \log Z(x) - \beta \log \frac{\pi_r(y_2\mid x)}{\pi_{\text{ref}}(y_2\mid x)} - \beta \log Z(x)\right)\] \[= \sigma\left(\beta \log \frac{\pi_r(y_1\mid x)}{\pi_{\text{ref}}(y_1\mid x)} - \beta \log \frac{\pi_r(y_2\mid x)}{\pi_{\text{ref}}(y_2\mid x)}\right)\] <p>Now, the partition function \(Z(x)\) cancels out, and we can express the probability of one response being preferred over another directly in terms of the policy ratios, without needing to compute the intractable normalizing constant.</p> <p>This cancellation is the key mathematical insight that makes DPO possible. It allows us to bypass both explicit reward modeling and reinforcement learning, and instead directly optimize a policy to predict human preferences.</p> <h2>Direct Preference Optimization</h2> <p>Direct Preference Optimization (DPO) leverages this mathematical insight we just explored to create a dramatically simpler approach to preference-based alignment. Instead of the three-stage pipeline of traditional RLHF, DPO offers a direct path from human preferences to an optimized language model.</p> <h4>The DPO Objective</h4> <p>DPO formulates a simple objective function that directly optimizes a policy \(\pi_\theta\) to align with human preferences:</p> \[\mathcal{L}_{\text{DPO}}(\pi_\theta; \pi_{\text{ref}}) = -\mathbb{E}_{(x,y_w,y_l) \sim \mathcal{D}}\left[\log \sigma\left(\beta \log \frac{\pi_\theta(y_w\mid x)}{\pi_{\text{ref}}(y_w\mid x)} - \beta \log \frac{\pi_\theta(y_l\mid x)}{\pi_{\text{ref}}(y_l\mid x)}\right)\right]\] <p>where:</p> <ul> <li>\(\pi_\theta\) is the policy we’re optimizing</li> <li>\(\pi_{\text{ref}}\) is the reference policy</li> <li>\((x, y_w, y_l)\) represents a preference pair where \(y_w\) is preferred over \(y_l\) for prompt \(x\)</li> <li>\(\beta\) controls the strength of the KL penalty</li> <li>\(\sigma\) is the logistic function</li> </ul> <p>This objective has an intuitive interpretation: it increases the probability of preferred responses relative to dispreferred responses, but does so in a way that accounts for the reference model’s probabilities and includes an implicit KL penalty to prevent diverging too far from the reference model.</p> <h4>The Elegant Simplicity of DPO</h4> <p>The beauty of DPO lies in its simplicity. Instead of the complex pipeline of traditional RLHF, DPO requires just two steps:</p> <h4>The DPO Approach</h4> <ol> <li>Train a reference model (e.g., through supervised fine-tuning)</li> <li>Directly optimize a policy to satisfy human preferences using the DPO objective</li> </ol> <p>This approach offers several compelling advantages:</p> <ul> <li> <strong>Simplicity</strong>: A single optimization step replaces the multi-stage RLHF pipeline</li> <li> <strong>Stability</strong>: Using a simple classification loss is more stable than RL optimization</li> <li> <strong>Efficiency</strong>: Avoids the computational overhead of RL algorithms</li> <li> <strong>Theoretical elegance</strong>: Directly optimizes the same underlying objective as RLHF</li> <li> <strong>Interpretability</strong>: The implicit reward is directly tied to the policy</li> </ul> <p>In essence, DPO accomplishes with one elegant step what traditional RLHF does with a complex pipeline of reward modeling and reinforcement learning.</p> <h4>Understanding the DPO Update</h4> <p>To build intuition for how DPO works, let’s examine how it updates the policy. The gradient of the DPO loss with respect to the model parameters has the form:</p> \[\nabla_\theta \mathcal{L}_{\text{DPO}} \propto -\beta \cdot \sigma(\hat{r}_\theta(x, y_l) - \hat{r}_\theta(x, y_w)) \cdot (\nabla_\theta \log \pi_\theta(y_w\mid x) - \nabla_\theta \log \pi_\theta(y_l\mid x))\] <p>where \(\hat{r}_\theta(x, y) = \beta \log \frac{\pi_\theta(y\mid x)}{\pi_{\text{ref}}(y\mid x)}\) is the implicit reward.</p> <p>This update has a natural interpretation:</p> <ul> <li>It increases the probability of the preferred response (\(y_w\))</li> <li>It decreases the probability of the dispreferred response (\(y_l\))</li> <li>The magnitude of the update is larger when the current implicit reward incorrectly ranks the responses</li> <li>The KL penalty \(\beta\) controls the overall magnitude of updates</li> </ul> <p>In essence, DPO performs a form of preference learning that directly updates the policy to better align with human preferences, without the detour through explicit reward modeling and reinforcement learning.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Mike Zhou. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0823RLC0T3"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0823RLC0T3");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>