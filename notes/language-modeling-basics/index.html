<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content=""> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Language Modeling Foundations | Mike Zhou </title> <meta name="author" content="Mike Zhou"> <meta name="description" content="An Introduction to Language Modeling"> <meta name="keywords" content="Mike Zhou, UPenn, University of Pennsylvania, Computer Science, Mathematics, NLP, Machine Learning, Cognitive Computation Group, Penn SEAS, undergraduate researcher"> <meta property="og:site_name" content="Mike Zhou"> <meta property="og:type" content="website"> <meta property="og:title" content="Mike Zhou | Language Modeling Foundations"> <meta property="og:url" content="https://mikezhou.me/notes/language-modeling-basics/"> <meta property="og:description" content="An Introduction to Language Modeling"> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Language Modeling Foundations"> <meta name="twitter:description" content="An Introduction to Language Modeling"> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Mike Zhou"
        },
        "url": "https://mikezhou.me/notes/language-modeling-basics/",
        "@type": "WebSite",
        "description": "An Introduction to Language Modeling",
        "headline": "Language Modeling Foundations",
        
        "sameAs": ["https://scholar.google.com/citations?user=qc6CJjYAAAAJ"],
        
        "name": "Mike Zhou",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://mikezhou.me/notes/language-modeling-basics/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Mike</span> Zhou </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item active"> <a class="nav-link" href="/notes/">notes <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/about/">about </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Language Modeling Foundations</h1> <p class="post-description">An Introduction to Language Modeling</p> </header> <article> <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0823RLC0T3"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0823RLC0T3");</script> <p>To begin our discussion of what a language model is, we first have to formally define what a language is. The simplest structure we can start with is the idea of an alphabet, which is merely just a set of symbols denoted as \(\Sigma\). From our alphabet, we can build strings, which are finite sequences of symbols formed by concatenation. Since concatenation is associative, we can define a concatenative closure, often called the Kleene closure of an alphabet, denoted as \(\Sigma^*\). Intuitively, this is just the set of all finite strings generated from our alphabet. Since the Kleene closure also includes the empty string, it provides a nice monoid we can work with. We then define a language as a subset of \(\Sigma^*\).</p> <p><b>Note on terminology:</b> The terminology we use here is drawn from formal language theory. In practical settings, we can normally substitute “alphabet” with any building block we use for language, like a <b> vocabulary </b> that will be comprised of either words or tokens. A string will then be synonymous with what we call sentences, and our language will be a subset of all possible sentences.</p> <p>We now have enough tools to define what a language model is. In natural language processing, we define a language model as a probability distribution over \(\Sigma^*\). There are two main types of language models, though only one is actually practical at the moment: we can either define one that is locally normalized (in which we define probabilities of strings through a sequence model) or globally normalized (which is energy based).</p> <h2>Globally Normalized Language Models</h2> <p>We will first talk about the less practical of the two models: globally normalized language models. A globally normalized language model is a model equipped with an energy function \(\hat{p}\), that maps values from \(\Sigma^*\) to the reals. Just as we commonly do in statistical learning theory, we define the unnormalized probability of a string \(y\) to be \(\text{exp}(-\hat{p}(y))\), and divide it by the normalization constant, \(Z = \sum_{y \in \Sigma^*}\text{exp}(-\hat{p}(y))\), to get the probability of generating that string. In other words:</p> \[p_{\text{LM}}(y) = \frac{\text{exp}(-\hat{p}(y))}{\sum_{y' \in \Sigma^*}\text{exp}(-\hat{p}(y'))}\] <p>At a first glance, this approach seems attractive since all we have to do is define an energy function to have our language model, which is often easier than setting a probability distribution. However, on a second glance, computing the normalization constant \(Z\) seems a bit unintuitive, as \(\Sigma^*\) contains infinitely many strings. Does it even converge? In addition, how would we sample?</p> <h2>Locally Normalized Language Models</h2> <p>The inherent difficulty of computing the normalization constant motivates the definition of the locally normalized language model. Rather than directly defining a language model as a distribution over \(\Sigma^*\), we can break our problem down into pieces, by generating a string a symbol at a time. The idea is, for each possible context \(y \in \Sigma^*\), we define the probability distribution over the conditional \(y\). In other words, we define a sequence model \(p_{\text{SM}}\) such that</p> \[p(xy) = p_{\text{SM}}(x \mid y)\] <p>where</p> \[\sum_{x \in \Sigma} p_{\text{SM}}(x \mid y) = 1\] <p>The probability of generating a string \(y\) is then</p> \[p_{\text{LM}}(y) = \prod_{l = 1}^L p_{\text{SM}}(y_l \mid y_{&lt;l})\] <p>It’s tempting to think that we’re done. But we’re not. Notice how since probabilities are at most 1, the probability of generating a string decreases with its length. Thus, statements like “Upenn is in” are more likely to be sampled than “UPenn is in Philadelphia”. To get around this, we introduce the EOS (End of String) symbol into the distribution, so that \(p_{S\text{SM}}\) maps values from \(\overline{\Sigma} = \Sigma \cup \{\text{EOS}\}\) to the reals. We then have that</p> \[p_{\text{LM}}(y) = p_{\text{SM}}(\text{EOS} \mid y)\prod_{l = 1}^L p_{\text{SM}}(y_l \mid y_{&lt;l})\] <h2>Count-Based N-gram Models</h2> <p>Having established the formal foundation for language models, let’s now explore one of the simplest practical implementations: count-based n-gram models. N-gram models make a strong Markov assumption that the probability of a word depends only on the n-1 preceding words. Formally, this gives us:</p> \[p_{\text{SM}}(y_l \mid y_{&lt;l}) \approx p_{\text{SM}}(y_l \mid y_{l-(n-1)}, \ldots, y_{l-1})\] <p>For instance, in a trigram model (n=3), we assume:</p> \[p_{\text{SM}}(y_l \mid y_{&lt;l}) \approx p_{\text{SM}}(y_l \mid y_{l-2}, y_{l-1})\] <p>To estimate these probabilities, we use the maximum likelihood estimate (MLE) based on corpus counts:</p> \[p_{\text{SM}}(y_l \mid y_{l-(n-1)}, \ldots, y_{l-1}) = \frac{C(y_{l-(n-1)}, \ldots, y_{l-1}, y_l)}{C(y_{l-(n-1)}, \ldots, y_{l-1})}\] <p>where \(C(\cdot)\) denotes the count of occurrences in our training corpus.</p> <p><b>Note on data sparsity:</b> While n-gram models are conceptually simple, they suffer from data sparsity issues. As n increases, the number of possible n-grams grows exponentially, making it increasingly likely that valid n-grams will not appear in our training data, resulting in zero probabilities. This issue is particularly problematic because multiplying by zero in our chain rule formula would zero out the probability of the entire sequence.</p> <p>To address this problem, we employ various smoothing techniques:</p> <ol> <li> <p><b>Laplace (Add-1) Smoothing:</b> Add 1 to all counts: \(p_{\text{SM}}(y_l \mid y_{l-(n-1)}, \ldots, y_{l-1}) = \frac{C(y_{l-(n-1)}, \ldots, y_{l-1}, y_l) + 1}{C(y_{l-(n-1)}, \ldots, y_{l-1}) + |\Sigma|}\)</p> </li> <li> <p><b>Add-k Smoothing:</b> A generalization of Laplace smoothing where we add k (0 &lt; k &lt; 1) instead of 1.</p> </li> <li> <p><b>Backoff Models:</b> If an n-gram has zero count, we “back off” to the (n-1)-gram.</p> </li> <li> <p><b>Interpolation:</b> Combine probabilities from different order n-grams: \(p_{\text{interp}}(y_l \mid y_{l-(n-1)}, \ldots, y_{l-1}) = \lambda_1 p(y_l \mid y_{l-(n-1)}, \ldots, y_{l-1}) + \lambda_2 p(y_l \mid y_{l-(n-2)}, \ldots, y_{l-1}) + \ldots + \lambda_n p(y_l)\) where \(\sum_i \lambda_i = 1\) and \(\lambda_i \geq 0\).</p> </li> <li> <p><b>Kneser-Ney Smoothing:</b> A more sophisticated smoothing technique that considers the diversity of contexts in which a word appears, not just its frequency.</p> </li> </ol> <p>Despite their simplicity, n-gram models dominated the field of language modeling for decades. However, they have inherent limitations: they can only capture short-range dependencies due to the Markov assumption, and they suffer from the curse of dimensionality as n increases.</p> <h2>Representation-Based Models</h2> <p>The limitations of n-gram models motivate the development of representation-based approaches, which learn continuous vector representations (embeddings) of words and contexts.</p> <h3>Word Embeddings</h3> <p>Word embeddings map words from a discrete space (the vocabulary) to a continuous vector space \(\mathbb{R}^d\), where semantically similar words are positioned closer together. This addresses two fundamental issues with n-gram models:</p> <ol> <li>They capture semantic relationships between words, enabling better generalization.</li> <li>They provide a more compact representation, mitigating the curse of dimensionality.</li> </ol> <table> <tbody> <tr> <td>Formally, we define an embedding matrix $$E \in \mathbb{R}^{</td> <td>\Sigma</td> <td>\times d}\(, where each row\)E_i$$ corresponds to the d-dimensional embedding of the i-th word in our vocabulary. These embeddings can be learned through various methods:</td> </tr> </tbody> </table> <ol> <li> <p><b>Count-based methods:</b> Such as Latent Semantic Analysis (LSA), which applies singular value decomposition to word-context co-occurrence matrices.</p> </li> <li> <p><b>Prediction-based methods:</b> Like Word2Vec (Skip-gram and CBOW) and GloVe, which learn embeddings by predicting words given their contexts or vice versa.</p> </li> </ol> <p>For instance, in the Skip-gram model, we maximize:</p> \[\sum_{t=1}^T \sum_{-c \leq j \leq c, j \neq 0} \log p(w_{t+j} | w_t)\] <p>where c is the context window size, and</p> \[p(w_{t+j} | w_t) = \frac{\exp(v_{w_{t+j}}^T \cdot v_{w_t})}{\sum_{w' \in \Sigma} \exp(v_{w'}^T \cdot v_{w_t})}\] <p>Here, \(v_w\) represents the vector embedding of word w.</p> <h3>Recurrent Neural Networks (RNNs)</h3> <p>Embeddings provide a powerful way to represent individual words, but language modeling requires capturing sequential dependencies. Recurrent Neural Networks (RNNs) address this by maintaining a hidden state that evolves as they process a sequence, enabling them to capture long-range dependencies beyond the fixed context window of n-gram models.</p> <h4>Intuition for RNNs</h4> <p>The key intuition behind RNNs is that they mimic how humans process language sequentially while maintaining context. When we read or hear a sentence, we don’t start from scratch with each new word; instead, we update our understanding based on previous words. RNNs formalize this by maintaining a hidden state that acts as a “memory” of what has been seen so far.</p> <p>Consider the sentence “The cat sat on the mat.” As we process each word:</p> <ol> <li>“The”: Initialize our context (this is a determiner, likely to be followed by a noun).</li> <li>“cat”: Update our context (now we know the subject is a cat).</li> <li>“sat”: Update again (now we understand the action). And so on.</li> </ol> <p>This sequential processing with memory enables RNNs to model complex language phenomena like agreement, ambiguity resolution, and even limited forms of reasoning.</p> <h4>Technical Details of Simple RNNs (Elman Networks)</h4> <p><img src="https://mikezhou.me/assets/img/elmann-rnn-diagram.png" alt="Digram of Training an RNN"></p> <p>Formally, an Elman RNN processes a sequence \(y_1, y_2, \ldots, y_L\) as follows:</p> <ol> <li> <p>Each word \(y_t\) is first converted to its embedding representation \(e_t = E_{y_t}\).</p> </li> <li> <p>The network computes a hidden state \(h_t\) based on the current input and the previous hidden state:</p> \[h_t = \tanh(W_h h_{t-1} + W_x e_t + b_h)\] <p>where \(W_h \in \mathbb{R}^{d_h \times d_h}\) is the hidden-to-hidden weight matrix, \(W_x \in \mathbb{R}^{d_h \times d}\) is the input-to-hidden weight matrix, and \(b_h \in \mathbb{R}^{d_h}\) is a bias term. The initial hidden state \(h_0\) is typically set to a vector of zeros.</p> </li> <li> <p>The output layer then converts the hidden state into a probability distribution over the vocabulary for the next word:</p> \[o_t = W_o h_t + b_o\] \[p(y_{t+1} | y_{\leq t}) = \text{softmax}(o_t)\] <table> <tbody> <tr> <td>where $$W_o \in \mathbb{R}^{</td> <td>\Sigma</td> <td>\times d_h}\(is the output weight matrix and\)b_o \in \mathbb{R}^{</td> <td>\Sigma</td> <td>}$$ is the output bias.</td> </tr> </tbody> </table> </li> </ol> <p>Specifically, the softmax function converts the output logits into a proper probability distribution:</p> \[p(y_{t+1} = w | y_{\leq t}) = \frac{\exp(o_{t,w})}{\sum_{w' \in \Sigma} \exp(o_{t,w'})}\] <p>where \(o_{t,w}\) is the component of the output vector corresponding to word w.</p> <h4>Training RNNs</h4> <p>RNNs are trained using the maximum likelihood principle, which for language modeling translates to minimizing the negative log-likelihood of the training data:</p> \[\mathcal{L} = -\sum_{t=1}^{L-1} \log p(y_{t+1} | y_{\leq t})\] <p>This is often referred to as minimizing the cross-entropy loss. The optimization is done using backpropagation through time (BPTT), which is a variant of the standard backpropagation algorithm adapted for sequential models. In BPTT, we unroll the RNN for a fixed number of steps and then apply backpropagation to compute gradients.</p> <h4>Challenges with Simple RNNs</h4> <p>While simple RNNs (Elman networks) represent a significant improvement over n-gram models, they still face challenges:</p> <ol> <li> <p><b>Vanishing and exploding gradients:</b> During training with BPTT, gradients can either vanish or explode as they are propagated back through time, making it difficult to learn long-range dependencies.</p> </li> <li> <p><b>Limited memory capacity:</b> The fixed-size hidden state can struggle to retain information over very long sequences.</p> </li> </ol> <p>These challenges led to the development of more sophisticated architectures like Long Short-Term Memory (LSTM) networks and Gated Recurrent Units (GRUs), which incorporate gating mechanisms to better control information flow and mitigate the vanishing gradient problem.</p> <h3>Conclusion</h3> <p>We have covered the foundations of language modeling, from formal definitions to practical implementations. We started with count-based n-gram models, which make strong Markov assumptions but suffer from data sparsity and limited context. We then moved to representation-based approaches, discussing word embeddings that capture semantic relationships and RNNs that model sequential dependencies.</p> <p>This progression reflects the historical development of language modeling, with each approach addressing limitations of its predecessors. Modern language models build upon these foundations, incorporating attention mechanisms, transformers, and pre-training on massive corpora to achieve unprecedented performance across a wide range of natural language processing tasks.</p> <p>As language modeling continues to evolve, understanding these foundational concepts remains crucial for developing intuition about how these models work and their inherent strengths and limitations.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Mike Zhou. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0823RLC0T3"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0823RLC0T3");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>